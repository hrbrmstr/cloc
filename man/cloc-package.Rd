% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cloc-package.r
\docType{package}
\name{cloc-package}
\alias{cloc-package}
\title{Count Lines of Code, Comments and Whitespace in Source Files and Archives}
\description{
Counts blank lines, comment lines, and physical lines of source code in source
files/trees/archives. An R wrapper to the Perl \code{cloc} utility
\url{https://github.com/AlDanial/cloc} by @AlDanial.
}
\section{How it works}{

\code{cloc}'s method of operation resembles \href{https://www.dwheeler.com/sloccount/}{SLOCCount}'s:
First, create a list of files to consider. Next, attempt to determine whether or not
found files contain recognized computer language source code. Finally, for files
identified as source files, invoke language-specific routines to count the number of
source lines.

A more detailed description:
\enumerate{
\item If the input file is an archive (such as a \code{.tar.gz} or \code{.zip} file),
create a temporary directory and expand the archive there using a
system call to an appropriate underlying utility (\code{tar}, \code{bzip2}, \code{unzip},
etc) then add this temporary directory as one of the inputs. (This
works more reliably on Unix than on Windows.)
\item Use perl's \code{File::Find} to recursively descend the input directories and make
a list of candidate file names. Ignore binary and zero-sized files.
\item Make sure the files in the candidate list have unique contents
(first by comparing file sizes, then, for similarly sized files,
compare MD5 hashes of the file contents with perl's \code{Digest::MD5}). For each
set of identical files, remove all but the first copy, as determined
by a lexical sort, of identical files from the set. The removed
files are not included in the report.
\item Scan the candidate file list for file extensions which cloc
associates with programming languages. Files which match are classified as
containing source
code for that language. Each file without an extensions is opened
and its first line read to see if it is a Unix shell script
(anything that begins with \code{#!}). If it is shell script, the file is
classified by that scripting language (if the language is
recognized). If the file does not have a recognized extension or is
not a recognzied scripting language, the file is ignored.
\item All remaining files in the candidate list should now be source files
for known programming languages. For each of these files:
\enumerate{
\item Read the entire file into memory.
\item Count the number of lines (= L \emph{original}).
\item Remove blank lines, then count again (= L \emph{non-blank}).
\item Loop over the comment filters defined for this language. (For
example, C++ as two filters: (1) remove lines that start with
optional whitespace followed by \code{//} and (2) remove text between
\code{/*} and \code{*/}) Apply each filter to the code to remove comments.
Count the left over lines (= L \emph{code}).
\item Save the counts for this language:
\itemize{
\item blank lines = L \emph{original} - L \emph{non-blank}
\item comment lines = L \emph{non-blank} - L \emph{code}
\item code lines = L \emph{code}
}
}
}
}

\author{
Bob Rudis (bob@rud.is)
}
